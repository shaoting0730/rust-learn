1 、`悬垂指针`: 指向已删除（或释放）的内存位置的指针称为悬垂指针  `空指针`： NULL指针是没有指向任何内容的指针 `野指针`： 尚未初始化为任何值（甚至不是NULL）的指针称为野生指针 <br/>
2 、 `rustc` 是Rust编程语言的编译器；`Cargo` 是Rust的构建系统和包管理器；`Cargo`负责管理Rust项目的构建、依赖管理和代码分发，`Cargo`的设计目标是简化Rust项目的管理和构建过程，使开发者能够更加专注于编写代码而不必担心构建系统的细节。<br/>
3、所有权是 Rust 语言为高效使用内存而设计的语法机制。所有权是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。<br/>
4、所有权有以下三条规则：

- Rust 中的每个值都有一个变量，称为其所有者。
* 一次只能有一个所有者。
+ 当所有者不在程序运行范围时，该值将被删除。

5、"引用"是变量的间接访问方式 <br/>
6、引用不会获得值的所有权。引用只能租借（Borrow）值的所有权。<br/>
7、函数（function,如abc和main）和方法（impl块中的area）:
结构体Rectangle，结构体方法定义在impl中, area就是一个结构体方法; abc和main是一个函数
```
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}

fn abc(){
  // ......
}

```
8、特征（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特征与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。<br/>

```

 impl <特性名> for <所实现的类型名>

 trait Descriptive {
    fn describe(&self) -> String;
}

struct Person {
    name: String,
    age: u8
}

impl Descriptive for Person {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
} 

```
8、Rust 宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。<br/>

宏（Macro）是一种在代码中进行元编程（Metaprogramming）的技术，它允许在编译时生成代码，宏可以帮助简化代码，提高代码的可读性和可维护性，同时允许开发者在编译时执行一些代码生成的操作。<br/>

宏在 Rust 中有两种类型：声明式宏（Declarative Macros）和过程宏（Procedural Macros）。<br/>

9、元组：是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。<br/>
   数组：将多个值组合在一起的另一种方式就是使用数组（Array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。<br/>
   Vector:  动态的数组（元素、和长度可以变化） Vector对数组 类似于 String对&Str  <br/>
   不确定是使用数组还是 Vector，那就应该使用一个 Vector <br/>
10、impl ：方法   fn :函数  <br/>
    parameter： 形参  argument： 实参  <br/>
11、语句（statement）是执行一些操作但不返回值的指令。 <br/>
    表达式（expression）计算并产生一个值（有返回值）。 Rust 是一门基于表达式（expression-based）的语言。函数调用是一个表达式。宏调用是一个表达式，我们用来创建新作用域的大括号（代码块） {} 也是一个表达式。表达式的结尾没有分号 <br/>
    ```
    
    fn area(width: u32, height: u32) -> u32 {
       width * height
    }

    fn area1() -> u32 {
       2;   //   2; 是一个语句
       1    //   1  是一个表达式，会作为返回值
    }
    
    ```
12、代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。   <br/> 
13、所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制（Java、Python），在`程序运行时`不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存（C、c++）。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在`编译时`会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序    <br/>
14、&：`引用` , *： `解引用`； <br/> 
    将创建一个引用的行为称为 `借用`   <br/> 
15、可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用 <br/> 
    这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它由这三个行为造成：<br/> 
>  两个或更多指针同时访问同一数据。<br/> 
>  至少有一个指针被用来写入数据。 <br/> 
>  没有同步数据访问的机制。<br/>

16、不能对一个不可变变量拥有可变引用。<br/>
    不能对一个可变变量同时拥有不可变引用和可变引用。<br/>
    可以对一个不可变变量拥有多个不可变引用<br/>
    可以对一个可变变量拥有多个不可变引用<br/>
> 注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止

17、
```
   rust完美的避开了这个bug
    let mut s = String::from("hello world");

    let word = first_word(&s);  // 不可变引用
    s.clear(); // error!   // 可变引用

    println!("the first word is: {}", word);

```

