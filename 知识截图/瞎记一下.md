1 、`悬垂指针`: 指向已删除（或释放）的内存位置的指针称为悬垂指针  `空指针`： NULL指针是没有指向任何内容的指针 `野指针`： 尚未初始化为任何值（甚至不是NULL）的指针称为野生指针 <br/>
2 、 `rustc` 是Rust编程语言的编译器；`Cargo` 是Rust的构建系统和包管理器；`Cargo`负责管理Rust项目的构建、依赖管理和代码分发，`Cargo`的设计目标是简化Rust项目的管理和构建过程，使开发者能够更加专注于编写代码而不必担心构建系统的细节。<br/>
3、所有权是 Rust 语言为高效使用内存而设计的语法机制。所有权是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。<br/>
4、所有权有以下三条规则：

- Rust 中的每个值都有一个变量，称为其所有者。
* 一次只能有一个所有者。
+ 当所有者不在程序运行范围时，该值将被删除。

5、"引用"是变量的间接访问方式 <br/>
6、引用不会获得值的所有权。引用只能租借（Borrow）值的所有权。<br/>
7、函数（function,如abc和main）和方法（impl块中的area，implementation的简写）:
结构体Rectangle，结构体方法定义在impl中, area就是一个结构体方法; abc和main是一个函数
```
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}

fn abc(){
  // ......
}

```
8、特征（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特征与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。<br/>

```

 impl <特性名> for <所实现的类型名>

 trait Descriptive {
    fn describe(&self) -> String;
}

struct Person {
    name: String,
    age: u8
}

impl Descriptive for Person {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
} 

```
8、Rust 宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。<br/>

宏（Macro）是一种在代码中进行元编程（Metaprogramming）的技术，它允许在编译时生成代码，宏可以帮助简化代码，提高代码的可读性和可维护性，同时允许开发者在编译时执行一些代码生成的操作。<br/>

宏在 Rust 中有两种类型：声明式宏（Declarative Macros）和过程宏（Procedural Macros）。<br/>

9、元组：是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。<br/>
   数组：将多个值组合在一起的另一种方式就是使用数组（Array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。<br/>
   Vector:  动态的数组（元素、和长度可以变化） Vector对数组 类似于 String对&Str  <br/>
   不确定是使用数组还是 Vector，那就应该使用一个 Vector <br/>
10、impl ：方法   fn :函数  <br/>
    parameter： 形参  argument： 实参  <br/>
11、语句（statement）是执行一些操作但不返回值的指令。 <br/>
    表达式（expression）计算并产生一个值（有返回值）。 Rust 是一门基于表达式（expression-based）的语言。函数调用是一个表达式。宏调用是一个表达式，我们用来创建新作用域的大括号（代码块） {} 也是一个表达式。表达式的结尾没有分号 <br/>
    ```
    
    fn area(width: u32, height: u32) -> u32 {
       width * height
    }

    fn area1() -> u32 {
       2;   //   2; 是一个语句
       1    //   1  是一个表达式，会作为返回值
    }
    
    ```
12、代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。   <br/> 
13、所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制（Java、Python），在`程序运行时`不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存（C、c++）。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在`编译时`会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序    <br/>
14、&：`引用` , *： `解引用`； <br/> 
    将创建一个引用的行为称为 `借用`   <br/> 
15、可变引用有一个很大的限制：在同一时间，只能有一个对某一特定数据的可变引用 <br/> 
    这个限制的好处是 Rust 可以在编译时就避免数据竞争。数据竞争（data race）类似于竞态条件，它由这三个行为造成：<br/> 
>  两个或更多指针同时访问同一数据。<br/> 
>  至少有一个指针被用来写入数据。 <br/> 
>  没有同步数据访问的机制。<br/>

16、不能对一个不可变变量拥有可变引用。<br/>
    不能对一个可变变量同时拥有不可变引用和可变引用。<br/>
    可以对一个不可变变量拥有多个不可变引用<br/>
    可以对一个可变变量拥有多个不可变引用<br/>
> 注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止

17、
```
   rust完美的避开了这个bug
    let mut s = String::from("hello world");

    let word = first_word(&s);  // 不可变引用
    s.clear(); // error!   // 可变引用

    println!("the first word is: {}", word);

```
18、关联函数：<br/>
所有在 `impl` 块中定义的函数被称为关联函数（associated function）,我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例。<br/>
19、match：控制流运算符，`match`关键字后跟一个表达式,类似于`if`语句的功能. Rust 中的匹配是穷举式的 ，Rust 还提供了一个模式，当我们不想使用通配模式获取的值时，请使用 `_` ，这是一个特殊的模式，可以匹配任意值而不绑定到该值 <br/>
20、if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。<br/>
21、Rust 有许多功能可以让你管理代码的组织，包括哪些内容可以被公开，哪些内容作为私有部分，以及程序每个作用域中的名字。这些功能。这有时被称为 `模块系统（the module system）`，包括：
包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。<br/>

- `Crates` ：一个模块的树形结构，它形成了库或二进制项目。
* `模块（Modules）和 use`： 允许你控制作用域和路径的私有性。
+ `路径（path）`：一个命名例如结构体、函数或模块等项的方式。 （不就是单纯的文件路径吗）<br/>

22、包和`crate`<br/>
`crate` 是一个二进制项或者库 <br/>
包（package）是提供一系列功能的一个或者多个 `crate`。<br/>
一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。包中所包含的内容由几条规则来确立。一个包中至多 只能 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的。如： 我们有了一个只包含 src/main.rs 的包，意味着它只含有一个名为 my-project 的二进制 crate。如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。<br/>
23、使用路径的方式，就像在文件系统使用路径一样。如果我们想要调用一个函数，我们需要知道它的路径。<br/>
路径有两种形式：<br/>
绝对路径（absolute path）从 crate 根部开始，以 crate 名或者字面量 crate 开头。<br/>
相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。<br/>


  
