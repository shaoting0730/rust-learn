1 、`悬垂指针`: 指向已删除（或释放）的内存位置的指针称为悬垂指针  `空指针`： NULL指针是没有指向任何内容的指针 `野指针`： 尚未初始化为任何值（甚至不是NULL）的指针称为野生指针 <br/>
2 、 `rustc` 是Rust编程语言的编译器；`Cargo` 是Rust的构建系统和包管理器；`Cargo`负责管理Rust项目的构建、依赖管理和代码分发，`Cargo`的设计目标是简化Rust项目的管理和构建过程，使开发者能够更加专注于编写代码而不必担心构建系统的细节。<br/>
3、所有权是 Rust 语言为高效使用内存而设计的语法机制。所有权是为了让 Rust 在编译阶段更有效地分析内存资源的有用性以实现内存管理而诞生的概念。br/>
4、所有权有以下三条规则：<br/>
①、Rust 中的每个值都有一个变量，称为其所有者。<br/>
②、一次只能有一个所有者。<br/>
③、当所有者不在程序运行范围时，该值将被删除。<br/>
5、"引用"是变量的间接访问方式 <br/>
6、引用不会获得值的所有权。引用只能租借（Borrow）值的所有权。<br/>
7、函数（function）和方法（impl）:
结构体Rectangle，结构体方法impl, 函数create
```
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn create(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }
}

fn main() {
    let rect = Rectangle::create(30, 50);
    println!("{:?}", rect);
}

```
8、特征（trait）概念接近于 Java 中的接口（Interface），但两者不完全相同。特征与接口相同的地方在于它们都是一种行为规范，可以用于标识哪些类有哪些方法。<br/>

```

 impl <特性名> for <所实现的类型名>

 trait Descriptive {
    fn describe(&self) -> String;
}

struct Person {
    name: String,
    age: u8
}

impl Descriptive for Person {
    fn describe(&self) -> String {
        format!("{} {}", self.name, self.age)
    }
} 

```
8、Rust 宏（Macros）是一种在编译时生成代码的强大工具，它允许你在编写代码时创建自定义语法扩展。<br/>

宏（Macro）是一种在代码中进行元编程（Metaprogramming）的技术，它允许在编译时生成代码，宏可以帮助简化代码，提高代码的可读性和可维护性，同时允许开发者在编译时执行一些代码生成的操作。<br/>

宏在 Rust 中有两种类型：声明式宏（Declarative Macros）和过程宏（Procedural Macros）。<br/>

9、元组：是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。<br/>
   数组：将多个值组合在一起的另一种方式就是使用数组（array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。<br/>
   Vector:  动态的数组（元素、和长度可以变化）<br/>

